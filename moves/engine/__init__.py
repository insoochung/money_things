"""Shared models and enums for the money_moves execution engine.

This module defines the core data types used across the entire money_moves system.
It serves as the single source of truth for all enums (Side, SignalAction, SignalStatus,
etc.) and Pydantic models (Position, Lot, Thesis, Signal, Order, Trade, etc.) that are
shared between the engine, broker, database, and API layers.

All models use Pydantic BaseModel for validation and serialization. Fields that correspond
to database primary keys (e.g., ``id``) are optional (``int | None``) because they are
assigned by SQLite on insert. Timestamp fields (``created_at``, ``updated_at``) are strings
in ISO 8601 format, populated by the engine at creation/mutation time.

This module is imported extensively throughout the codebase:
    - ``engine.signals`` uses Signal, SignalAction, SignalSource, SignalStatus
    - ``engine.thesis`` uses Thesis, ThesisStatus
    - ``engine.risk`` uses Signal, SignalAction
    - ``engine.principles`` uses ActorType
    - ``broker.base`` and ``broker.mock`` use Order, OrderResult, OrderPreview, Position, etc.
    - ``db.seed`` uses various models for seeding

Enums use ``StrEnum`` so they serialize to their string values in JSON and database storage,
making them human-readable in audit logs, API responses, and database queries.

Models overview:
    - Position: Aggregated share count for a symbol in an account (long or short).
    - Lot: Individual tax lot with cost basis, acquired date, and holding period for
      tax-aware trading (FIFO consumption on sell, short-term vs long-term classification).
    - Thesis: Investment thesis pushed from money_thoughts with validation/failure criteria
      and a state machine lifecycle (active -> strengthening -> confirmed -> weakening ->
      invalidated -> archived).
    - Signal: Trading signal generated by the signal engine, flows through a lifecycle of
      pending -> approved/rejected/ignored/cancelled -> executed.
    - Order: Broker order created from an approved signal.
    - Trade: Executed fill record with realized P/L tracking.
    - AccountBalance: Cash, total value, and buying power snapshot.
    - OrderResult: Broker response after placing an order.
    - OrderPreview: Pre-trade cost/commission estimate.
    - AuditEntry: Immutable audit log record for every system action.
"""

from __future__ import annotations

from enum import StrEnum

from pydantic import BaseModel, Field

# --- Enums ---


class Side(StrEnum):
    """Position direction: long (buy-and-hold) or short (borrow-and-sell).

    Used in Position and Lot models to distinguish between long and short positions.
    The money_moves system supports both long and short strategies, though the initial
    implementation focuses primarily on long positions for RSU holdings and thesis-driven
    buys.
    """

    LONG = "long"
    SHORT = "short"


class SignalAction(StrEnum):
    """Action type for trading signals and orders.

    Defines the four possible trading actions in the system:
        - BUY: Open or add to a long position
        - SELL: Reduce or close a long position (triggers FIFO lot consumption)
        - SHORT: Open or add to a short position
        - COVER: Reduce or close a short position

    Used in Signal, Order, and Trade models. The mock broker applies different logic
    for each action: BUY/COVER deduct cash, SELL/SHORT add cash. Slippage is applied
    in opposite directions for buys vs sells.
    """

    BUY = "BUY"
    SELL = "SELL"
    SHORT = "SHORT"
    COVER = "COVER"


class SignalStatus(StrEnum):
    """Lifecycle status of a trading signal.

    Signals flow through this state machine:
        pending -> approved -> executed   (happy path)
        pending -> rejected               (user explicitly rejects via Telegram)
        pending -> ignored                (24h timeout with no user response)
        pending -> cancelled              (system cancellation, e.g., kill switch)
        approved -> executed              (broker fills the order)
        pending -> expired                (alternative expiry path)

    Both 'rejected' and 'ignored' statuses create what_if records for tracking
    counterfactual outcomes. The distinction matters for learning: rejected means
    the user actively disagreed with the signal, while ignored means they did not
    engage (different levels of conviction).
    """

    PENDING = "pending"
    APPROVED = "approved"
    REJECTED = "rejected"
    IGNORED = "ignored"
    EXECUTED = "executed"
    EXPIRED = "expired"
    CANCELLED = "cancelled"


class SignalSource(StrEnum):
    """Origin of a trading signal.

    Tracks where a signal came from, which feeds into the confidence scoring system.
    Each source type has its own historical accuracy tracked in the signal_scores table,
    used as a multiplier during confidence scoring.

    Sources:
        - THESIS_UPDATE: Thesis status change triggered re-evaluation
        - PRICE_TRIGGER: Price crossed a predefined threshold
        - NEWS_EVENT: Breaking news affecting a thesis
        - CONGRESS_TRADE: Congressional trading disclosure (politician trades)
        - DISCOVERY: New ticker discovered through thesis universe expansion
        - MANUAL: User-initiated signal (default)
    """

    THESIS_UPDATE = "thesis_update"
    PRICE_TRIGGER = "price_trigger"
    NEWS_EVENT = "news_event"
    CONGRESS_TRADE = "congress_trade"
    DISCOVERY = "discovery"
    MANUAL = "manual"


class ThesisStatus(StrEnum):
    """Lifecycle status of an investment thesis.

    Theses follow a state machine with validated transitions (defined in
    engine.thesis.VALID_TRANSITIONS). The status affects signal confidence
    scoring through the THESIS_STRENGTH multiplier map:
        - active: 1.0x (neutral baseline)
        - strengthening: 1.1x (positive evidence accumulating)
        - confirmed: 1.2x (thesis validated by outcomes)
        - weakening: 0.6x (negative evidence, reduced conviction)
        - invalidated: 0.0x (thesis failed, blocks all signals)
        - archived: 0.0x (terminal state, no new signals)

    Valid transitions are enforced by ThesisEngine.transition_status() and each
    transition creates a thesis_versions record for audit history.
    """

    ACTIVE = "active"
    STRENGTHENING = "strengthening"
    CONFIRMED = "confirmed"
    WEAKENING = "weakening"
    INVALIDATED = "invalidated"
    ARCHIVED = "archived"


class OrderType(StrEnum):
    """Order type for broker execution.

    Currently supports:
        - MARKET: Execute immediately at best available price
        - LIMIT: Execute only at specified price or better

    The mock broker treats all orders as instant fills at the current yfinance price
    (with optional slippage). Limit order logic will be implemented for the live
    Schwab broker integration.
    """

    MARKET = "market"
    LIMIT = "limit"


class OrderStatus(StrEnum):
    """Status of a broker order.

    Order lifecycle:
        - PENDING: Created but not yet submitted to broker
        - SUBMITTED: Sent to broker, awaiting fill
        - FILLED: Fully executed
        - PARTIAL: Partially filled (some shares remain)
        - CANCELLED: Cancelled by user or system
        - REJECTED: Broker rejected the order (insufficient funds, invalid symbol, etc.)

    The mock broker transitions directly from PENDING to FILLED (instant fills).
    The live Schwab broker will use the full lifecycle with polling for status updates.
    """

    PENDING = "pending"
    SUBMITTED = "submitted"
    FILLED = "filled"
    PARTIAL = "partial"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


class ActorType(StrEnum):
    """Actor that initiated an action in the audit log.

    Every entry in the audit_log table records which actor type performed the action,
    enabling filtering and analysis of system vs user-initiated actions.

    Actor types:
        - ENGINE: Automated engine actions (signal creation, risk checks, principle updates)
        - USER: Direct user actions (manual signal creation, thesis updates)
        - SCHEDULER: Scheduled task actions (periodic portfolio valuation, signal expiry)
        - TELEGRAM: Actions initiated through the Telegram bot (approve/reject signals)
        - API: Actions initiated through the REST API (dashboard interactions)
    """

    ENGINE = "engine"
    USER = "user"
    SCHEDULER = "scheduler"
    TELEGRAM = "telegram"
    API = "api"


# --- Models ---


class Position(BaseModel):
    """Aggregated position for a symbol in an account.

    Represents the total shares held for a single symbol, with a weighted average cost
    basis. Positions are updated by the broker on BUY (increase shares, recalculate
    avg_cost) and SELL (decrease shares, delete if zero).

    A position can be linked to a thesis_id to track which investment thesis it belongs
    to, and has a strategy field (e.g., 'RSU hold', 'long', 'short') for categorization.

    The underlying tax lots are tracked separately in the Lot model for tax-aware
    accounting. The position's avg_cost is the weighted average of all open lots.

    Attributes:
        id: Database primary key, assigned on insert.
        account_id: Foreign key to the accounts table.
        symbol: Ticker symbol (e.g., 'NVDA', 'META').
        shares: Total number of shares held (sum of all open lots).
        avg_cost: Weighted average cost per share across all open lots.
        side: Position direction - 'long' or 'short'.
        strategy: Descriptive label for the position strategy.
        thesis_id: Foreign key to the theses table, linking position to its thesis.
        created_at: ISO 8601 timestamp of position creation.
        updated_at: ISO 8601 timestamp of last modification.
    """

    id: int | None = None
    account_id: int | None = None
    symbol: str
    shares: float
    avg_cost: float
    side: Side = Side.LONG
    strategy: str = ""
    thesis_id: int | None = None
    created_at: str = ""
    updated_at: str = ""


class Lot(BaseModel):
    """Individual tax lot for a position.

    Tax lots track the cost basis, acquisition date, and holding period for each
    discrete purchase or RSU vest. This enables tax-aware trading decisions:
        - FIFO lot consumption on SELL (oldest lots sold first)
        - Short-term vs long-term capital gains classification
        - Tax-loss harvesting identification
        - Funding plan generation (which lot to sell to fund a new purchase)

    When shares are sold, the MockBroker._consume_lots_fifo() method closes lots
    in FIFO order (by acquired_date). Partial closes reduce the lot's shares and
    cost_basis proportionally.

    Attributes:
        id: Database primary key.
        position_id: Foreign key to the positions table.
        account_id: Foreign key to the accounts table.
        symbol: Ticker symbol for this lot.
        shares: Number of shares remaining in this lot (decreases on partial sell).
        cost_basis: Total cost basis for the remaining shares in this lot.
        acquired_date: ISO 8601 date when shares were acquired (for FIFO ordering).
        source: How shares were acquired (e.g., 'trade', 'RSU').
        holding_period: 'Short Term' or 'Long Term' based on acquisition date.
        closed_date: ISO 8601 date when lot was fully closed (None if still open).
        closed_price: Price per share at which lot was closed (None if still open).
    """

    id: int | None = None
    position_id: int | None = None
    account_id: int | None = None
    symbol: str
    shares: float
    cost_basis: float
    acquired_date: str
    source: str = ""
    holding_period: str = ""
    closed_date: str | None = None
    closed_price: float | None = None


class Thesis(BaseModel):
    """Investment thesis with state machine lifecycle and versioned history.

    A thesis is the fundamental unit of the money_moves system. Every signal and
    position should be tied to a thesis, enforcing the "thesis-first" philosophy
    where macro beliefs drive individual ticker decisions.

    Theses are created by money_thoughts (the thinking module) and pushed to
    money_moves (the execution module) via the API. The thesis engine manages
    status transitions, versioning, and symbol universe management.

    The status field follows a state machine (see ThesisStatus and
    engine.thesis.VALID_TRANSITIONS) and directly impacts signal confidence
    scoring through the THESIS_STRENGTH multiplier map.

    Attributes:
        id: Database primary key.
        title: Short descriptive title of the thesis.
        thesis_text: Full thesis narrative explaining the investment rationale.
        strategy: Trading strategy ('long', 'short', 'pair').
        status: Current lifecycle status (see ThesisStatus).
        symbols: List of ticker symbols aligned with this thesis.
        universe_keywords: Keywords for discovering new tickers aligned with thesis.
        validation_criteria: Conditions that would strengthen/confirm the thesis.
        failure_criteria: Conditions that would weaken/invalidate the thesis.
        horizon: Investment time horizon (e.g., '6m', '1y', '2y').
        conviction: Conviction level from 0.0 to 1.0 (set by user/money_thoughts).
        source_module: Which module created this thesis (e.g., 'money_thoughts', 'money_journal').
        created_at: ISO 8601 timestamp of thesis creation.
        updated_at: ISO 8601 timestamp of last modification.
    """

    id: int | None = None
    title: str
    thesis_text: str = ""
    strategy: str = "long"
    status: ThesisStatus = ThesisStatus.ACTIVE
    symbols: list[str] = Field(default_factory=list)
    universe_keywords: list[str] = Field(default_factory=list)
    validation_criteria: list[str] = Field(default_factory=list)
    failure_criteria: list[str] = Field(default_factory=list)
    horizon: str = ""
    conviction: float = 0.5
    source_module: str = ""
    created_at: str = ""
    updated_at: str = ""


class Signal(BaseModel):
    """Trading signal with confidence scoring and lifecycle management.

    Signals are the primary output of the signal engine. They represent a recommendation
    to take a trading action (BUY/SELL/SHORT/COVER) on a specific symbol, backed by a
    thesis and scored for confidence.

    Signal lifecycle:
        1. Created by SignalEngine.create_signal() with status PENDING
        2. Sent to Telegram for user approval (telegram_msg_id tracks the message)
        3. User approves -> status becomes APPROVED, order is placed
           User rejects -> status becomes REJECTED, what_if record created
           No response in 24h -> status becomes IGNORED, what_if record created
           Kill switch/risk -> status becomes CANCELLED
        4. After successful broker fill -> status becomes EXECUTED

    The confidence field is computed by SignalEngine.score_confidence() using a multi-layer
    scoring pipeline: raw confidence * thesis strength * domain expertise * source accuracy
    + principle adjustments, clamped to [0.0, 1.0].

    Attributes:
        id: Database primary key.
        action: Trading action (BUY, SELL, SHORT, COVER).
        symbol: Ticker symbol to trade.
        thesis_id: Foreign key to the thesis driving this signal.
        confidence: Computed confidence score in [0.0, 1.0].
        source: What triggered this signal (see SignalSource).
        horizon: Time horizon for the trade.
        reasoning: Human-readable explanation of why this signal was generated.
        size_pct: Suggested position size as percentage of portfolio NAV.
        funding_plan: JSON description of how to fund the trade (which lots to sell).
        status: Current lifecycle status (see SignalStatus).
        telegram_msg_id: Telegram message ID for tracking approval callbacks.
        created_at: ISO 8601 timestamp of signal creation.
        decided_at: ISO 8601 timestamp when user approved/rejected.
        expired_at: ISO 8601 timestamp when signal expired (24h timeout).
    """

    id: int | None = None
    action: SignalAction
    symbol: str
    thesis_id: int | None = None
    confidence: float = 0.5
    source: SignalSource = SignalSource.MANUAL
    horizon: str = ""
    reasoning: str = ""
    size_pct: float | None = None
    funding_plan: str | None = None
    status: SignalStatus = SignalStatus.PENDING
    telegram_msg_id: str | None = None
    created_at: str = ""
    decided_at: str | None = None
    expired_at: str | None = None


class Order(BaseModel):
    """Broker order created from an approved signal.

    Orders are the interface between the signal engine and the broker. When a signal
    is approved, an Order is created and passed to the broker's place_order() method.
    The broker fills the order and returns an OrderResult.

    In mock mode, orders are instantly filled at the current yfinance price (with
    optional slippage). In live mode, orders will be submitted to Schwab's API and
    polled for status updates.

    Attributes:
        id: Database primary key (assigned after recording the order).
        signal_id: Foreign key to the signal that triggered this order.
        order_type: Market or limit order.
        symbol: Ticker symbol to trade.
        action: Trading action (BUY, SELL, SHORT, COVER).
        shares: Number of shares to trade.
        limit_price: Limit price for limit orders (None for market orders).
        status: Current order status (see OrderStatus).
        schwab_order_id: Schwab API order ID for live mode tracking.
        submitted_at: ISO 8601 timestamp when order was sent to broker.
        filled_at: ISO 8601 timestamp when order was fully filled.
        cancelled_at: ISO 8601 timestamp when order was cancelled.
        error_message: Error message if order was rejected.
    """

    id: int | None = None
    signal_id: int | None = None
    order_type: OrderType = OrderType.MARKET
    symbol: str = ""
    action: SignalAction = SignalAction.BUY
    shares: float = 0
    limit_price: float | None = None
    status: OrderStatus = OrderStatus.PENDING
    schwab_order_id: str | None = None
    submitted_at: str | None = None
    filled_at: str | None = None
    cancelled_at: str | None = None
    error_message: str | None = None


class Trade(BaseModel):
    """Record of an executed trade (broker fill).

    Trades are immutable records created by the broker after successfully filling
    an order. They capture the exact fill price, shares, and realized P/L (for sells).
    Each trade is linked back to the originating signal for audit trail purposes.

    The realized_pnl field is calculated by the MockBroker._consume_lots_fifo() method
    during SELL orders, comparing the sell price against the cost basis of consumed lots.

    Attributes:
        id: Database primary key.
        signal_id: Foreign key to the originating signal.
        symbol: Ticker symbol that was traded.
        action: Trading action that was executed.
        shares: Number of shares that were filled.
        price: Fill price per share.
        total_value: Total trade value (price * shares).
        lot_id: Foreign key to the lot created (for BUY) or consumed (for SELL).
        fees: Broker fees/commissions (0 for mock broker).
        broker: Which broker executed the trade ('mock' or 'schwab').
        account_id: Foreign key to the account used for the trade.
        realized_pnl: Realized profit/loss for SELL trades (None for BUY trades).
        timestamp: ISO 8601 timestamp of the trade execution.
    """

    id: int | None = None
    signal_id: int | None = None
    symbol: str
    action: SignalAction
    shares: float
    price: float
    total_value: float = 0
    lot_id: int | None = None
    fees: float = 0
    broker: str = ""
    account_id: int | None = None
    realized_pnl: float | None = None
    timestamp: str = ""


class AccountBalance(BaseModel):
    """Snapshot of account balance and buying power.

    Returned by broker.get_account_balance() to provide current cash, total portfolio
    value, and available buying power. Used by the mock broker to check if there is
    sufficient cash for BUY orders before execution.

    In mock mode, buying_power equals cash. In live mode with margin accounts,
    buying_power may exceed cash.

    Attributes:
        cash: Available cash balance in the account.
        total_value: Total portfolio value (cash + positions).
        buying_power: Available buying power (cash in mock mode, may include margin in live).
    """

    cash: float = 0
    total_value: float = 0
    buying_power: float = 0


class OrderResult(BaseModel):
    """Result returned by the broker after placing an order.

    Contains the fill details (price, shares) and status after the broker processes
    an order. Used by the caller to determine if the order was successfully filled
    or rejected, and to record the trade.

    Attributes:
        order_id: Broker-assigned order ID (database row ID for mock broker).
        status: Final status of the order after processing.
        filled_price: Price per share at which the order was filled (None if not filled).
        filled_shares: Number of shares that were filled (None if not filled).
        message: Human-readable status message (e.g., 'Filled BUY 10 NVDA @ $130.00').
    """

    order_id: str
    status: OrderStatus
    filled_price: float | None = None
    filled_shares: float | None = None
    message: str = ""


class OrderPreview(BaseModel):
    """Pre-trade cost estimate before order submission.

    Returned by broker.preview_order() to show the user estimated costs before
    they approve a signal. Used in the Telegram approval message and dashboard
    to display expected impact.

    Attributes:
        estimated_cost: Total estimated cost of the order (price * shares).
        estimated_price: Current market price used for the estimate.
        commission: Expected broker commission/fees.
        warnings: List of warning messages (e.g., 'Price unavailable').
    """

    estimated_cost: float = 0
    estimated_price: float = 0
    commission: float = 0
    warnings: list[str] = Field(default_factory=list)


class AuditEntry(BaseModel):
    """Immutable audit log entry for tracking all system actions.

    Every significant action in the money_moves system creates an audit_log entry,
    providing a complete trail of who did what, when, and to which entity. This is
    critical for compliance, debugging, and the feedback loop back to money_thoughts.

    Audit entries are created by the _audit() helper functions in each engine module
    (signals, thesis, risk, principles, broker). They are never updated or deleted.

    Attributes:
        actor: Who performed the action (engine, user, scheduler, telegram, api).
        action: What action was performed (e.g., 'signal_created', 'trade_executed').
        details: Additional context about the action (e.g., transition reason).
        entity_type: Type of entity affected (e.g., 'signal', 'thesis', 'trade').
        entity_id: Database ID of the affected entity (None for system-wide actions).
    """

    actor: ActorType
    action: str
    details: str = ""
    entity_type: str = ""
    entity_id: int | None = None
